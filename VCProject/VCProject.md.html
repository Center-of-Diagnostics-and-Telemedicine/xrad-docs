<meta charset="utf-8" lang="ru">

**Система сборки проектов XRAD для Visual Studio 2015**



# Устройство проектов С++ Visual Studio #

Проект C++ среды Visual Studio 2015 состоит из файлов (`$(name)` означает имя проекта):
- `$(name).vcxproj`: основной файл, задает список файлов проекта и набор опций компилятора,
  линкера.
- `$(name).vcxproj.filters`: вспомогательный файл, задает способ логической группировки
  файлов проекта в среде (структуру логических папок типа Sources, Includes или любую
  другую).
- `$(name).vcxproj.user` (может отсутствовать): содержит список опций, уникальных для
  пользователя (командная строка для запуска отлаживаемого модуля, настройки отладчика,
  дополнительные переменные среды). Этот файл не должен храниться в системе контроля версий.
- набор файлов `*.props` (опционально, расширение может отличаться): набор опций компилятора,
  линкера. Обычно один файл подключается к нескольким проектов. Это механизм, позволяющий
  централизовано задавать настройки для нескольких проектов.



# Файл vcxproj #

Файл проекта vcxproj состоит из нескольких разделов:

TODO: MSVC 2019 + Qt

1. `&lt;ItemGroup Label="ProjectConfigurations"&gt;`

  Здесь задается набор конфигураций и платформ проекта. Управление осуществляется в диалоге
  Configuration Manager. Стандартный набор конфигураций и платформ:
  <ul>
  <li>`Debug|Win32`
  <li>`Release|Win32`
  <li>`Debug|x64`
  <li>`Release|x64`
  </ul>

  Порядок перечисления может быть произвольным. При наведении порядка в проекте желательно
  упорядочивать конфигурации указанным образом.

  Дополнительные конфигурации XRAD:
  - `DebugEHA`, `ReleaseEHA`: конфигурации с обработкой аппаратных исключений.

1. `&lt;PropertyGroup Label="Globals"&gt;`

  Здесь задается набор глобальных свойств проекта. Некоторые задаются в панели Properties
  для файла vcxproj (не в диалоге свойств проекта, а именно в панели свойств),
  некоторые в диалоге свойств проекта, раздел General.

  Стандартно мы задаем свойства:

  - `ProjectGuid`: уникальный GUID вида `{A4E4DA46-FB04-4136-8DDB-054096569D78}`.
    Генерируется средой при создании проекта. Необходимо менять при создании копии проекта.
    Не редактируется в среде.
  - `RootNamespace`: сюда записываем имя проекта. Возможно, это поле не используется в C++.
  - `WindowsTargetPlatformVersion`: сюда записываем значение `8.1` (по умолчанию).
  - `ProjectName`: задает имя проекта, если оно должно по каким-то причинам отличаться
    от имени файла проекта. Стараемся не задавать этот параметр, а давать нужное имя
    файлу проекта.
  - `Keyword`: не задаем. (MSVC 2019 + Qt: `QtVS_v302`.)

1. `&lt;Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" /&gt;`

  Эта инструкция подключает стандартный набор значений по умолчанию проекта C++.

1. `&lt;PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'"&gt;`

  Этот раздел задается для каждого набора конфигурация | платформа (`Debug|Win32` и т.д.).
  Порядок следования конфигураций и платформ может быть произвольным.
  При наведении порядка в проекте желательно упорядочивать их так же, как в разделе
  `ProjectConfigurations`.

  Здесь задается набор базовых свойств каждой конфигурации. Управление осуществляется
  в диалоге свойств проекта, раздел General. Мы задаем параметры:

  - `ConfigurationType`: тип проекта: `Application`, `StaticLibrary`, `DynamicLibrary`.
  - `UseDebugLibraries`: `true` для конфигураций Debug, `false` для конфигураций Release.
    Это очень важный параметр, по нему устанавливаются значения по умолчанию многих опций
    компилятора и линкера. В силу неизвестных причин этот параметр недоступен для редактирования
    из GUI среды Visual Studio, также он не устанавливается при конвертации проектов предыдущих
    версий Visual Studio. Требуется редактирование файла проекта в текстовом редакторе.
    При создании нового проекта этот параметр устанавливается верно.
  - `PlatformToolset`: задаем значение по умолчанию `v140`.
  - `CharacterSet`: этот параметр мы не задаем, кроме проектов, использующих внешние библиотеки,
    которые иначе не собираются.

1. `&lt;Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" /&gt;`

  Эта инструкция подключает стандартный property sheet, который по заданным перед этим
  параметрам (тип проекта, UseDebugLibraries, ...) устанавливает значения по умолчанию для опций
  компилятора и линкера.

1. `&lt;ImportGroup Label="ExtensionSettings"&gt;`

  Здесь, веротяно, подключаются property sheets для опций дополнительных инструментов сборки (типа
  MASM), не являющихся стандартными для C/C++. Например, здесь может находиться следующая
  инструкция:

  ~~~~ none
  &lt;Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" /&gt;
  ~~~~

  Поскольку мы не используем дополнительные инструменты, этот раздел рекомендуется оставлять
  пустым.

1. `&lt;ImportGroup Label="Shared"&gt;`

  Пустой раздел. Назначение неизвестно.

1.  `&lt;ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'"&gt;`

  Набор разделов для каждого набора конфигурация | платформа.
  Порядок следования конфигураций и платформ может быть произвольным.
  При наведении порядка в проекте желательно упорядочивать их так же, как в разделе
  `ProjectConfigurations`.

  Здесь подключаются пользовательские property sheets. Управление осуществляется в панели Property
  Manager (не путать с панелью Properties). Порядок следования property sheets _имеет_ значение.
  Следующий property sheet может использовать переменные, заданные в предыдущих property sheets, и
  изменять заданные там значения опций.

  По умолчанию включается следующий property sheet:

  `&lt;Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props"`
  `Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')"`
  `Label="LocalAppDataPlatform" /&gt;`

  Этот property sheet позволяет задать опции, специфические для компьютера и пользователя.
  Например, здесь можно задать переменные, которые будут использоваться при сборке проекта,
  если нежелательно задавать их в переменных среды операционной системы.

  Также сюда подключаются property sheets XRAD инструкциями вида:

  `&lt;Import Project="$(XRADRoot)\XRADGUI\MSVC\XRADGUI.props" /&gt;`

  Список property sheets XRAD:

  <ul>
  <li>`$(XRADRoot)\XRADBasic\MSVC\XRADBasic.props`:
    Базовый набор опций. Используется в библиотеках, использующих только математику (без GUI).

  <li>`$(XRADRoot)\XRADConsoleUI\MSVC\XRADConsoleUI.props`:
    Набор опций для консольных приложений.

    Включает в себя:
    - `XRADSystem.props`

  <li>`$(XRADRoot)\XRADQt\MSVC\XRADQt.props`:
    Базовый набор опций для подключения Qt. Используется в приложениях, которые используют
    Qt напрямую, без XRADGUI.

  <li>`$(XRADRoot)\XRADGUI\MSVC\XRADGUI.props`:
    Набор опций для GUI-приложений, а также библиотек, использующих GUI.

    Включает в себя:
    - `XRADBasic.props`
    - `XRADQt.props`

  <li>`$(XRADRoot)\XRADDicom\MSVC\XRADDicom.props`:
    Набор опций для приложений и библиотек, использующих XRADDicom (без XRADDicomGUI).

  <li>`$(XRADRoot)\XRADDicomGUI\MSVC\XRADDicomGUI.props`:
    Набор опций для приложений и библиотек, использующих XRADDicomGUI.

    Включает в себя:
    - `XRADDicom.props`

  <li>`$(XRADRoot)\XRADSystem\MSVC\XRADSystem.props`:
    Набор опций для библиотек, использующих XRAD (без GUI).

    Включает в себя:
    - `XRADBasic.props`
  </ul>

  Для конфигураций, имена которых отличаются от стандартных (перечислены выше),
  существуют варианты перечисленных property sheets с суффиксами `-debug` и `-release`,
  которые задают debug и release значения параметров. Для конфигураций с обработкой исключений
  существует property sheet:

  `$(XRADRoot)\XRADBasic\MSVC\XRAD-EHA.props`

  Для статических библиотек, которые должны попадать в папку `%XRADInstall%\lib\...`, предназначен
  property sheet:

  `$(XRADRoot)\XRADBasic\MSVC\XRAD-StdTarget.props`

  Он задает суффикс имени lib-файла в зависимости от конфигурации, а также задает
  post build event: вызов `$(ProjectDir)$(ProjectName)_Lib_PostBuild.bat`.

1. `&lt;PropertyGroup Label="UserMacros" /&gt;`

  Пустой раздел. Не используется.

1. Раздел `_ProjectFileVersion`

  ~~~~ none
  &lt;PropertyGroup&gt;
    &lt;_ProjectFileVersion&gt;14.0.25123.0&lt;/_ProjectFileVersion&gt;
  &lt;/PropertyGroup&gt;
  ~~~~

  Этот раздел создается при конвертации проекта предыдущих версий Visual Studio.
  Он не используется, удаляем его.

1. `&lt;PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'"&gt;`

  Набор разделов для каждого набора конфигурация | платформа.
  Порядок следования конфигураций и платформ может быть произвольным.
  При наведении порядка в проекте желательно упорядочивать их так же, как в разделе
  `ProjectConfigurations`.

  Здесь задаются параметры типа `IntDir`, `OutDir`. Управление осуществляется в диалоге свойств
  проекта, раздел General.

  В текущей концепции использования proprety sheets эти разделы должны быть пустыми,
  все значения задаются в property sheets XRAD.

1. `&lt;ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'"&gt;`

  Набор разделов для каждого набора конфигурация | платформа.
  Порядок следования конфигураций и платформ может быть произвольным.
  При наведении порядка в проекте желательно упорядочивать их так же, как в разделе
  `ProjectConfigurations`.

  Здесь задаются опции компилятора C/C++, компилятора ресурсов, линкера,
  сборщика статических библиотека и т.д.
  Упрвление осуществляется в диалоге свойств проекта, разделы C/C++, Resources, Linker,
  Librarian, Build Event.

  Большинство опций должны наследоваться от property sheets XRAD и не задваться явным образом.

  Следующие опции должны, как правило, определяться в проекте:

  - "C/C++ | General | Additional Include Directories" (`ClCompile/AdditionalIncludeDirectories`):

    Задаются дополнительны include-пути, обязательно
    включается наследование значений ("Inherit from parent or project default" /
    `%(AdditionalIncludeDirectories)`).

    Например, для использования VLD он мог бы содержать следующее значение:

    ~~~~ none
    $(XRADThirdParty)\vld\include;%(AdditionalIncludeDirectories)
    ~~~~

    Замечание: Пути к библиотеке VLD уже заданы в `XRADBasic.props`, их задавать не надо.

    Этот параметр должен задаваться одинаковым для всех конфигураций.

  - "C/C++ | Command Line | Additional Options" (`ClCompile/AdditionalOptions`):

    Задаются дополнительные параметры компилятора,
    для которых не предусмотрено именованных опций.
    Такие как `bigobj`: `/bigobj %(AdditionalOptions)`.

    Замечание: Параметр `/bigobj` уже задан в `XRADBasic.props`, его задавать не надо.

  - "Liner | General | Additional Library Directories" (`Link/AdditionalLibraryDirectories`):

    Задаются дополнительные папки поиска lib-файлов. Должно быть включено наследование
    значений по умолчанию ("Inherit from parent or project default" /
    `%(AdditionalLibraryDirectories)`).

    Например, для использования VLD он мог бы содержать следующее значение:

    ~~~~ none
    $(XRADThirdParty)\vld\lib\$(PlatformTarget);%(AdditionalLibraryDirectories)
    ~~~~

    В настоящее время пути к библиотеке VLD уже заданы в `XRADBasic.props`,
    этот параметр в большинстве проектов должен быть пустым.

    Этот параметр должен задаваться одинаковым для всех конфигураций.

  - "Build Events | Post-Build Event" (`PostBuildEvent`):

    Задается сценарий, выполняемый после сборки проекта.

    Стандартные сценарии уже заданы в props-файлах XRAD.

    Для использования своего сценария (`my_batch.bat params`) вместе со стандартными сценариями
    XRAD этот параметр должен содержать следующие инструкции:

    ~~~~ none
    %(Command)
    call "my_batch.bat" params
    ~~~~

1. Разделы со списком файлов проекта

  Управление списком файлов проекта осуществляется в панели Solution Explorer.
  Для каждого файла, перечисленного здесь, создается также запись в файле `*.vcxproj.filters`.

  - `ItemGroup/ClCompile`

    Список исходных файлов С++ (`*.cpp`).

    Для файла `pre.cpp` должен переопределяться параметр "C/C++ | Precompiled Headers |
    Precompiled Header" (`PrecompiledHeader`): `Create`.

    Для остальных файлов опции не должны переопределяться, кроме случаев оправданной
    необходимости и файлов, управляемых плагином Qt.

  - `ItemGroup/ClInclude`

    Список заголовочных файлов (`*.h`, `*.hh`).

    Опции для отдельных файлов не должны переопределяться.

  - `ItemGroup/ResourceCompile`

    Список файлов ресурсов Windows (`*.rc`).

    Опции для отдельных файлов не должны переопределяться.

  - `ItemGroup/CustomBuild` (Qt/moc)

    Список заголовочных файлов, обрабатываемых метакомпилятором Qt (`*.h`).

    Параметры задаются плагином Qt.

  - `ItemGroup/CustomBuild` (Qt/uic)

    Список файлов UI, обрабатываемых метакомпилятором Qt (`*.ui`).

    Параметры задаются плагином Qt.

  - `ItemGroup/CustomBuild` (Qt/rcc)

    Список файлов UI, обрабатываемых компилятором ресурсов Qt (`*.qrc`).

    Параметры задаются плагином Qt.

  - `ItemGroup/Text`

    Текстовый файл (`*.txt`).

  - `ItemGroup/Image`

    Файлы изображений. Используется в проектах Qt?

  - `ItemGroup/None`

    Прочие файлы (`*.bat` и т.п.).

1. `&lt;Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" /&gt;`

  Эта инструкция определяет механизмы сборки проекта.

1. `&lt;ImportGroup Label="ExtensionTargets"&gt;`

  Раздел, вероятно, предназначен для указания способов обработки файлов, не являющихся
  стандартными для C/C++. Может содержать, например, следующую инструкцию:

  ~~~~ none
  &lt;Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" /&gt;
  ~~~~

  Поскольку эти расширения мы не используем, рекомендуется делать этот раздел пустым.

1. `&lt;ProjectExtensions&gt;`

  Раздел с опциями плагинов. Должен присутствовать только для проектов, использующих Qt напрямую
  (не посредством функций XRADGUI).

  Для проектов Qt содержит параметр `VisualStudio/UserProperties` с опциями плагина Qt. Значения
  задаются в меню "QT5 | Qt Project Settings" (доступно только для проектов Qt).



# Стандартный набор конфигураций #



## Debug ##

Конфигурация для отладки. В компиляторе C++ устанавливается макроопределение `_DEBUG`
(это является признаком, отличающим эту конфигурацию от Release).
Отключена оптимизация кода, включены механизмы выявления ошибок работы с памятью и т.п.



## Release ##

Конфигурация для "релиза". В компиляторе C++ отсутствует макроопределение `_DEBUG`
(это является признаком, отличающим эту конфигурацию от Debug).
Также устанавливается макроопределение `NDEBUG`.
Включена оптимизация кода. Отладка возможна, но с некоторыми оговорками.
Например, порядок исполнения машинных инструкций может отличаться от следования порождающих их
операций в исходном коде.



## DebugEHA, ReleaseEHA ##

Аналоги Debug и Release с включенной обработкой аппаратных исключений.
В компиляторе C++ устанавливается макроопределение `XRAD_MSVC_EHA`.

Экспериментально используется макроопределение `XRAD_FP_EXCEPTIONS`:
устанавливается только в DebugEHA.
Включает аппаратные исключения для операций с плавающей точкой.

См. также документацию по классам SystemException, ThreadSetup и связанным с ним классами.

Замечание. Есть соображение переместить функциональность *EHA в Debug и Release
и сделать отдельные конфигурации без обработки исключений.



## Debug with direct link ##

Устаревшая конфигурация. Использовалась для включения некоторых файлов библиотек непосредственно
в проекты тестовых приложений. Есть соображения, что этот механизм не нужен при правильном
использовании файлов `*.pdb`.



# Размещение библиотек XRAD #

Для размещения библиотек (lib-файлов) предусмотрены две папки: локальная для решения (solution) и
глобальная.

- локальная папка библиотек проекта: `$(SolutionDir)lib\$(PlatformTarget)-$(Configuration)\`;
  в `XRADLibBasic.props` для неё устанавливается макрос (и переменная среды) `$(XRAD_LibDir)`;
- глобальная папка библиотек XRAD: `$(XRADInstall)\lib\MSVC2015\$(PlatformTarget)\`,
  `$(PlatformTarget)` = `x86` или `x64`;
  в `XRADLibBasic.props` для неё устанавливается макрос (и переменная среды) `$(XRAD_CommonLibDir)`.

Стандартные библиотеки XRAD (типа XRADBasic) могут собираться в рамках отдельных специальных
solution типа `XRADLibrariesBuild`. При сборке они помещаются в папку `$(XRAD_CommonLibDir)`.

В силу особенностей файлов precompiled headers, для устранения конфликтов сборки,
а также для обеспечения возможности собирать
библиотеки локально в рамках решений приложений сборка происходит сначала
в папке `$(XRAD_LibDir)`.
Затем в post build step вызывается скрипт `$(XRADRoot)\XRADBasic\MSVC\Lib_PostBuild.bat`,
который копирует библиотеку и файлы отладочной
информации в `%XRADInstall%\lib\VS2015`. Стандартный механизм подключения скрипта — включение
в проект `$(XRADRoot)\XRADBasic\MSVC\XRAD-StdTarget.props`.
Он записывает вызов скрипта `$(XRADRoot)\XRADBasic\MSVC\Lib_PostBuild.bat`,
а при наличии локального `$(ProjectName)_Lib_PostBuild.bat`,
вызывает также его с параметрами: `$(TargetPath) $(PlatformTarget)`.

Поскольку файлы библиотек разных конфигураций помещаются в одну общую папку, для различения
файлов разных конфигураций используются суффиксы имен файлов.

Требования к суффиксам:
- уникальность;
- имя одной библиотеки с некоторым набором суффиксов не должно совпадать
  с именем другой библиотеки с некоторым набором суффиксов.

Используются суффиксы:
- Release — без суффиксов;
- Debug — суффикс `D`;
- DebugEHA, ReleaseEHA — дополнительный суффикс `EHA`.

Нестандартные библиотеки (используемые только в рамках solution) следует размещать только в
локальной папке `$(XRAD_LibDir)`. При этом использование суффиксов не требуется, т.к. для каждой
конфигурации проекта используется своя lib-папка.

В пути поиска библиотек папки библиотек XRAD записываются в порядке:
`$(XRAD_CommonLibDir);$(XRAD_LibDir)`.
Поскольку при сборке общей библиотеки она всегда копируется в глобальную папку, искать её
нужно в первую очередь там. В противном случае возможно использование устаревших lib-файлов из
локальной папки, если в одной папке существуют два solution:
один без проектов общих библиотек, а другой с ними.
Сейчас таким примером являются `XRADLibrariesBuild.sln` (включает в частности XRADBasic) и
`XRADDicomTest.sln` (не включает XRADBasic, но содержит проект приложения, использующего её).

Подключение библиотек производится посредством включения include-файлов с инструкцией
`#pragma comment(lib, "lib_name.lib")`.

Для получения стандартного суффикса библиотеки используется файл `MSVC_XRADLink-Suffix.h`. Он
определяет макрос C++ `XRAD_Library_Suffix`.
Инструкция подключения стандартной библиотеки (с суффиксом) выглядит следующим образом:
~~~~ none
#pragma comment(lib, "lib_name" XRAD_Library_Suffix ".lib")
~~~~

В качестве примера см. `MSVC_XRADBasicLink.h`.



# Файлы отладочной информации #

В VisualC есть две разновидности файлов отладочной информации `*.pdb`:
файл, создаваемый компилятором, и файл, создаваемый линкером.

Для библиотек lib pdb-файл, создаваемый компилятором, должен лежать рядом с файлом lib
и иметь то же имя. В противном случае он не будет найден линкером при сборке приложения.
Для остальных типов проектов pdb-файл, создаваемый компилятором, может лежать в принципе
где угодно, лучше всего размещать его в папке `obj` ($(IntDir), опция по умолчанию).

Линкер не используется для библиотек lib. Для остальных типов проектов он по умолчанию создает
файл pdb рядом с выходным бинарным файлом и с тем же именем.
Вместе с файлом `*.pdb` может также создаваться файл `*.ilk`.
Если файл создавать в другом месте или с другим именем (соответствующие опции существуют),
отладчик не сможет его найти автоматически.
Создание файла отладочной информации для линкера возможно отключить:
опция "Linker | Generate Debug Info" (`Link/GenerateDebugInformation`).



# Precompiled headers #

Заголовочный файл прекомпилируемого заголовка должен всегда иметь имя `pre.h`. Имя cpp-файла
VisualC, который используется для создания прекомпилируемого заголовка, может иметь теоретически
любое имя. Рекомендуется использовать следующую схему:

- Для проектов приложений и dll использовать `pre.cpp`.

- Для проектов статических библиотек использовать `$(lib_name)_pre.cpp`, где `$(lib_name)` — имя
  библиотеки. Это нужно для того, чтобы при сборке приложения со статическими библиотеками не
  возникло конфликта имен модулей (несколько исходных файлов с одинаковыми именами `pre.cpp`,
  возможно, скомпилированные с разными опциями типа GUI / не GUI).

- Файл `pre.h` библиотеки должен располагаться в папке, которая не видна для проектов,
  использующих эту библиотеку (например, в подпапке `internal`). Путь к этой папке должен быть
  добавлен к include-путям в проекте сборки библиотеки.

- Если в одной папке размещено несколько проектов, для которых содержимое `pre.h` должно
  отличаться, соответствующие файлы `pre.h` должны размещаться в разных папках. Например:
  `internal-console/pre.h`, `internal-gui/pre.h`. В каждом проекте в include-пути записывается путь
  к одной соответствущей папке.



<style>
body {
  font-family:Arial;
  color:black;
  max-width:100%;
}
</style>
<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script>window.markdeepOptions = {mode: 'markdeep', detectMath: false};</script><script src="markdeep.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
