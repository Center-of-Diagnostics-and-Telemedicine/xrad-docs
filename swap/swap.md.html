<meta charset="utf-8">
<meta lang="ru">

**Оптимизированный обмен значений переменных функцией swap**



Для оптимального обмена значений двух переменных (объектов) используется
функция `swap`.

Шаблонная функция `swap` предоставляется стандартной библиотекой C++.
Кроме того, этот шаблон
может быть специализирован, а функция может быть перегружена пользователем для
своих типов. При написании специализаций и перегрузок следует придерживаться
определенных правил (некоторые из них обязательны в соответствии со стандартом
C++), для правильного использования этой функции также следует выполнять
определенные требования.



# Определение функции swap #



Функция `swap` определяется в пространстве имен `std`, имеет несколько
специализаций для классов стандартной библиотеки, а также может иметь
специализации и перегрузки, написанные пользователем для своих типов.

Множество доступных для использования вариантов функции `swap`, созданных с
соблюдением требований стандарта C++, следующее:

1. Функция `swap` в пространстве имен `std`:

  ~~~~ C++
  // &lt;utility&gt;

  template&lt; class T &gt;
  void swap( T& a, T& b );
  ~~~~

2. Специализации `std::swap` для некоторых типов из `std`. Набор этих специализаций
  определяется стандартом C++ и предоставляется стандартной библиотекой.

3. Специализации `std::swap`, сделанные пользователем в пространстве имен `std` для
  собственных типов данных.

4. Функции `swap`, написанные пользователем, в пространстве имен аргументов.

Остальные варианты по своей сути неправильные и приводят к нежелательным результатам.

К примеру, функция `swap`, объявленная для типов данных пользователя в
пространстве имен, отличном от пространства имен этих типов, не будет
найдена компилятором при использовании алгоритмов стандартной библиотеки,
использующих `swap`, с типами данных пользователя. Это обусловлено
правилами поиска функций (см. правило ADL, argument-dependent lookup). Вместо
функции `swap` пользователя будет использована `std::swap`. Поясним примером кода:

~~~~ C++
namespace MyNamespace
{

class SampleClass
{
  // Data fields...
};

} // namespace MyNamespace

using namespace MyNamespace;

void swap(SampleClass &a, SampleClass &b)
{
  // Swapping values of a and b here.
}

void DoSomething()
{
  auto v1 = std::make_pair(SampleClass(/*value*/), SampleClass(/*value*/));
  auto v2 = std::make_pair(SampleClass(/*value*/), SampleClass(/*value*/));

  using std::swap;
  swap(v1, v2);
  // Незапланированное поведение:
  // здесь при обмене полей first и second двух std::pair будет использована std::swap,
  // а не swap, написанная выше.
}
~~~~

Правила написания специализаций и перегруженных функций `swap` будут изложены
ниже.



# Использование функции swap #



Для правильного использования `swap` в программе нужно использовать следующую
конструкцию:

~~~~ C++
#include &lt;utility&gt;

void my_function_with_swap(T &a, T &b)
{
  using std::swap;
  swap(a, b);
}
~~~~

Декларация `using std::swap` не требуется, если она присутствует в окружающем блоке или
пространстве имен.

Важные моменты:

- Функция `std::swap` должна быть видна в месте вызова `swap`, поэтому необходимо
  включить заголовок `&lt;utility&gt;` и сделать `using std::swap`.

- Вызывать нужно функцию `swap` без имени пространства имен, чтобы поиск
  производился и в `std`, и в пространстве имен типов аргументов.

- Директива `using namespace std` также дает возможность использовать как перегрузку `swap`
  из пространства имен аргументов, так и `std::swap`. Но при этом получается другой способ
  выбора функции-кандидата. В стандарте указано использование декларации
  `using std::swap`, поэтому необходимо использовать именно её, причем даже при наличии
  директивы `using namespace std`. В противном случае возможны ситуации, когда в пользовательском
  коде и в алгоритмах стандартной библиотеки при работе с одними и теми же типами данных
  будут использоваться разные функции `swap` (пользовательская перегрузка `swap` и `std::swap`).

Замечания:

- Приведенные рекомендации особенно важны при написании кода шаблонов, в которых типы аргументов
  заранее неизвестны, поэтому неизвестно заранее, какая версия `swap` должна быть использована.

- Если мы точно знаем, что хотим использовать `std::swap`, а не пользовательскую
  функцию `swap`, допустимо писать `std::swap(a, b)`.

- Если мы точно знаем, что будет использоваться пользовательская функция `swap`,
  а не `std::swap`, допустимо не включать `&lt;utility&gt;` и не делать `using std::swap`.



# Правила написания специализаций и перегруженных функций swap #



## Написание специализаций std::swap ##

Написание специализации `std::swap` производится приблизительно следующим образом:

~~~~ C++
#include &lt;utility&gt;

namespace MyNamespace
{

class SampleClass
{
};

} // namespace MyNamespace

namespace std
{

template<>
void swap(MyNamespace::SampleClass &a, MyNamespace::SampleClass &b)
{
  // Implement swapping values of a and b here.
}

} // namespace std
~~~~



## Перегрузка swap ##

Перегрузка swap выполняется приблизительно следующим образом:

~~~~ C++
namespace MyNamespace
{

class SampleClass
{
};

// Внимание! Эта функция может использоваться не только для SampleClass,
// но и для его наследников.
void swap(SampleClass &a, SampleClass &b)
{
  // Implement swapping values of a and b here.
}

} // namespace MyNamespace
~~~~

У такого способа перегрузки есть побочный эффект. Перегруженная функция может быть
использована не только для объектов типа SampleClass, но и для объектов классов, унаследованных от
SampleClass. Иногда это может быть полезно, но чаще это может быть источником ошибок.
Рассмотрим пример:

~~~~ C++
#include &lt;SampleClass.h&gt;
#include &lt;utility&gt;
namespace MyNamespace
{

class SampleChild: public SampleClass
{
  public:
    int n;
};

void MyAlgorithm()
{
  SampleChild a, b;
  a.n = 1;
  b.n = 2;
  printf("Before: a.n=%i, b.n=%i\n", a.n, b.n);
  // using std::swap; -- "Забыли" добавить, или вместо этого добавили using namespace std.
  // Код компилируется.
  swap(a, b);
  printf("After: a.n=%i, b.n=%i\n", a.n, b.n);
}

} // namespace MyNamespace
~~~~

В результате вызова `MyAlgorithm()` мы получим:

~~~~ none
Before: a.n=1, b.n=2
After: a.n=1, b.n=2
~~~~

В то время как мы ожидали бы увидеть:

~~~~ none
After: a.n=2, b.n=1
~~~~

Это произошло потому, что здесь вызывается `void swap(SampleClass &a, SampleClass &b)`, которая
ничего не знает о данных наследников.

Проблему можно решить, написав перегруженную функцию `swap` для типа `SampleChild`. К сожалению,
в языке C++ нет механизмов, заставляющих пользователя предоставлять такие перегруженные функции
или хотя бы сигнализировать ему о необходимости их предоставления или о возможных побочных
эффектах при вызове `swap` для `SampleChild`.

Замечание. При использовании декларации `using std::swap` для `SampleChild` была бы использована
`std::swap` и результат получился бы верным. Но перемещение данных при этом не было бы
оптимизировано для `SampleChild::SampleClass`. Функция `std::swap` была бы выбрана потому, что её
шаблонный параметр обеспечивает точное совпадение типа аргументов функции, а у перегруженной
функции `swap` совпадение неточное.

Другая попытка (неудачная) решить проблему — перенести код обмена данных в виртуальный метод.

~~~~ C++
#include &lt;utility&gt; // не влияет на результат
namespace MyNamespace
{

class SampleClass
{
  public:
    // Тип other всегда совпадает с типом *this.
    virtual void DoSwap(SampleClass &other);
};

// Эта функция будет использована для SampleClass и для его наследников.
void swap(SampleClass &a, SampleClass &b)
{
  a.DoSwap(b);
}

class SampleChild: public SampleClass
{
  public:
    int n;
    virtual void DoSwap(SampleClass &other) override
    {
      SampleClass::DoSwap(other);
      int tmp = n;
      n = static_cast&lt;SampleChild&amp;&gt;(other).n;
      static_cast&lt;SampleChild&amp;&gt;(other).n = tmp;
    }
};

void MyAlgorithm()
{
  SampleChild a, b;
  a.n = 1;
  b.n = 2;
  printf("Before: a.n=%i, b.n=%i\n", a.n, b.n);
  // using std::swap; // Выбор функции swap зависит от наличия этой декларации.
  swap(a, b);
  printf("After: a.n=%i, b.n=%i\n", a.n, b.n);
}

} // namespace MyNamespace
~~~~

В результате вызова `MyAlgorithm()` мы получим желаемое конечное состояние переменных независимо
от наличия декларации `using std::swap`:

~~~~ none
Before: a.n=1, b.n=2
After: a.n=2, b.n=1
~~~~

Но мы не можем обеспечить использование нашей реализации `swap` при наличии `using std::swap`, а
также при вызове `swap` из алгоритмов стандартной библиотеки при работе с типом `SampleChild`
без написания перегрузок или специализаций `swap` для `SampleChild`.



## Рекомендации ##


<ul><li>
Для типов, хотя бы потенциально допускающих наследование, пользовательская функция `swap` должна
быть специализацией шаблона. В других случаях возможны нежелательные побочные эффекты.
</li><li>

Функцию `swap` нельзя определять в пространствах имен, отличных от `std` (здесь допускается
только специализация `std::swap`) и пространства имен типов аргументов
(второе, кстати, проблема, если типы аргументов разные и определены в разных
пространствах имен).
В противном случае эта функция не будет найдена, например, при вызове алгоритмов стандартной
библиотеки, использующих `swap`, таких как `std::sort`.
</li></ul>



# Замечания #

- При наличии одновременно перегрузки `swap` и специализации `std::swap`
  будет использоваться перегруженная функция, т.к. при совпадении типов аргументов
  перегруженная функция имеет приоритет над шаблонной.

- Не решен вопрос: Пусть есть базовый класс и его наследники. Можно ли написать такую функцию
  `swap`, которая бы использовалась и для базового класса, и для наследников?
  (Эта функция может вызывать виртуальный метод класса для выполнения работы
  по перемещению данных.) Можно попробовать реализовать как шаблонную функцию с `enable_if`.



# Литература #

- [C++ Reference: std::swap](https://en.cppreference.com/w/cpp/algorithm/swap)
- [C++ named requirements: Swappable](https://en.cppreference.com/w/cpp/named_req/Swappable)


<style>
body {
  max-width:100%;
}
.md pre {
  white-space:pre;
}
.md code {
  white-space:inherit;
}
.note {
  font-size:80%;
}
.comment {
  color:gray;
  font-size:80%;
}
</style>
<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script>window.markdeepOptions = {mode: 'markdeep', detectMath: false};</script><script src="markdeep.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
